## Updated `autoinstall.bat` file

<details>
  <summary>updated autoinstall.bat</summary>
  <br>

```batch
@echo off
setlocal enabledelayedexpansion

REM ============================================
REM Enhanced Batch Script with Chocolatey Install
REM ============================================

REM Define pause duration for message readability
set "PAUSE_DURATION=3"

REM Function to pause
:pauseForReadability
timeout /t %PAUSE_DURATION% >nul
exit /b

REM Function to display messages with color
:printMsg
set "type=%~1"
set "text=%~2"
if /I "%type%"=="info" echo [i] %text%
if /I "%type%"=="success" echo [Success] %text%
if /I "%type%"=="warning" echo [!] %text%
if /I "%type%"=="error" echo [x] %text%
exit /b

REM Step 1: Check for Chocolatey, and install if missing
call :printMsg info "Checking if Chocolatey is installed..."
choco -? >nul 2>&1
if %errorlevel% neq 0 (
    call :printMsg warning "Chocolatey is not installed. Installing Chocolatey via PowerShell..."
    powershell -NoProfile -ExecutionPolicy Bypass -Command ^
        "Set-ExecutionPolicy Bypass -Scope Process; ^
         [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; ^
         Invoke-WebRequest -Uri https://community.chocolatey.org/install.ps1 -UseBasicParsing | Invoke-Expression"
    
    if %errorlevel% neq 0 (
        call :printMsg error "Failed to install Chocolatey. Please check your internet connection or run the command manually."
        exit /b
    ) else (
        call :printMsg success "Chocolatey installed successfully."
    )
) else (
    call :printMsg success "Chocolatey is already installed."
)
call :pauseForReadability

REM Step 2: Check for Java installation (Version 8-21)
call :printMsg info "Checking for any Java version between 8 and 21..."
for /f "tokens=2 delims=[]" %%v in ('java -version 2>&1') do set "JAVA_VERSION=%%v"
set "JAVA_VERSION_MAJOR="
for /f "tokens=2 delims=. " %%v in ("%JAVA_VERSION%") do set "JAVA_VERSION_MAJOR=%%v"

if defined JAVA_VERSION_MAJOR (
    if %JAVA_VERSION_MAJOR% geq 8 if %JAVA_VERSION_MAJOR% leq 21 (
        call :printMsg success "Java version %JAVA_VERSION_MAJOR% is installed."
    ) else (
        call :printMsg warning "Java version is not within the range of 8-21. Installing OpenJDK 17..."
        choco install -y openjdk17
    )
) else (
    call :printMsg warning "Java is not installed. Installing OpenJDK 17..."
    choco install -y openjdk17
)
call :pauseForReadability

REM Step 3: Check for Node.js installation
call :printMsg info "Checking if Node.js is installed..."
where node >nul 2>&1
if %errorlevel% neq 0 (
    call :printMsg warning "Node.js is not installed. Installing Node.js and npm..."
    choco install -y nodejs
) else (
    call :printMsg success "Node.js is installed."
)
call :pauseForReadability

REM Step 4: Check for npm installation
call :printMsg info "Checking if npm is installed..."
where npm >nul 2>&1
if %errorlevel% neq 0 (
    call :printMsg warning "npm is not installed. Installing npm..."
    choco install -y npm
) else (
    call :printMsg success "npm is installed."
)
call :pauseForReadability

REM Script Completed
call :printMsg success "All checks and installations are complete."
exit /b
```
</details>
<br>

## Automatic application Wi-Fi IP Address (macOS and Linux support added with IPv6 and IPv4 support)

<details>
  <summary>Auto Wifi IP application (win32, linux, darwin)</summary>
<br>
  
```javascript
const os = require('os'); // Ensure you have the 'os' module imported

// Function to get Wi-Fi IP address (both IPv4 and IPv6)
function getWiFiIP() {
    const networkInterfaces = os.networkInterfaces();
    for (let interfaceName in networkInterfaces) {
        if (interfaceName.toLowerCase().includes('wi-fi')) { // Specifically look for 'Wi-Fi'
            for (let iface of networkInterfaces[interfaceName]) {
                if (!iface.internal) { // Ignore internal interfaces
                    if (iface.family === 'IPv4') {
                        return { ip: iface.address, type: 'IPv4' }; // Return IPv4 address
                    } else if (iface.family === 'IPv6') {
                        return { ip: iface.address, type: 'IPv6' }; // Return IPv6 address
                    }
                }
            }
        }
    }
    // If no IP address is found, return null to indicate failure
    return null;
}

// Function to Automatically set the IP address
$appCtrl.setWiFiIP = () => {
    const wifiInfo = getWiFiIP(); // Call the function to get Wi-Fi IP address
    if (wifiInfo) {
        $appCtrl.srcIP = wifiInfo.ip; // Set the IP address in the AngularJS model
        console.log(`Using ${wifiInfo.type} address: ${wifiInfo.ip}`); // Log the type of IP address used
    } else {
        // Log a warning message if the IP address cannot be set
        $appCtrl.Log('[!] Unable to Automatically Apply Your Private Wireless LAN adapter Wi-Fi address.', CONSTANTS.logStatus.WARNING);
        $appCtrl.Log('[¡] Please Enter it Manually.',  CONSTANTS.logStatus.INFO);
    }
};

// Detect tab click event and then call the function to set the Wi-Fi IP address
$(document).ready(function () {
    $('a.item').click(function () {
        const tab = $(this).attr('data-tab');
        if (tab === 'second') { // APK Builder tab
            $appCtrl.setWiFiIP(); // Set the IP when the APK Builder tab is clicked
            $appCtrl.$apply(); // Update the AngularJS scope manually
        }
    });
});
```
</details>
<br>

## Updated Launch/Activity based Search and Extract logic
> These updates should handle the most common edge cases when it comes to locating the Main Launcher Activity class or Main Application Class in Manifest Files. See "Potential Handled Edge Cases" for more info.

<details>
<summary>Potentially Handled Edge Cases</summary>
<br>

1. Missing or Invalid <application> Tag
   - Checks for the existence of the <application> tag and logs an error if it's missing.

2. Missing Package Name in <manifest>
   - Verifies that the package attribute exists in the manifest's root element and logs an error if it's absent.

3. Main Application Class Handling
   - Provided but a System Class: If the application class (android:name) starts with a system prefix (e.g., android.app, androidx), it is ignored.
   - Not Provided: Logs an informational message and proceeds to check for launcher activities.

4. Launcher Activities in <activity> Nodes
   - Disabled Activities: Filters out activities explicitly disabled via android:enabled="false".
   - Matching Intent Filters: Considers only activities that have an intent-filter with both the MAIN action and LAUNCHER category.
   - Multiple Intent Filters with Varying Priorities: Computes the highest priority among all intent-filters and sorts the activities accordingly.
   - Excluding System Classes: Discards activities that are identified as system classes based on known prefixes.

5. Launcher Activities via <activity-alias> Nodes
   - Disabled Aliases: Filters out activity aliases that are marked as disabled.
   - Matching Intent Filters: Checks that the alias has an intent-filter with the MAIN action and LAUNCHER category.
   - Extracting the Target Activity: Extracts the android:targetActivity attribute from the alias.
   - Avoiding Duplicates: Uses a Set to track and avoid duplicate target activities.

6. Fallback Handling When Nothing Is Found
   - Logs appropriate messages and returns null if neither a valid main application class nor a valid launcher activity (via activity or alias) is identified.
</details>
<details>
<summary>Code</summary>
<br>

```js
/**
 * Processes class names by handling fully qualified names.
 * @param {string} className - The class name to process.
 * @returns {string|null} - The processed class name with '.smali' appended, or null if the class name is empty.
 */
function processClassName(className) {
    if (!className) return null; // Handle empty class names

    // Return the class name by extracting the last part and appending '.smali'
    return `${className.split('.').pop()}.smali`;
}

/**
 * Checks if the class is a system class (like `android.app` or `androidx`).
 * @param {string} className - The class name to check.
 * @returns {boolean} - Whether the class name is a system class.
 */
const systemClassPrefixes = ['android.app', 'androidx', 'android.support', 'android.view', 'android.content'];
function isSystemClass(className) {
    return systemClassPrefixes.some(prefix => className.startsWith(prefix));
}

/**
 * Checks if an activity (or alias) element is enabled.
 * @param {object} element - The XML element to check.
 * @returns {boolean} - True if enabled or not explicitly disabled.
 */
function isEnabled(element) {
    // If no 'android:enabled' attribute is specified, assume it's enabled.
    return element?.['$']?.['android:enabled'] !== 'false';
}

/**
 * Checks if an intent-filter has the MAIN action and LAUNCHER category.
 * @param {object} filter - The intent-filter object to check.
 * @returns {boolean} - Whether the filter matches the main launcher activity.
 */
const isLauncherActivity = (filter) =>
    filter['action']?.some(action =>
        action['$']['android:name'] === 'android.intent.action.MAIN'
    ) &&
    filter['category']?.some(category =>
        category['$']['android:name'] === 'android.intent.category.LAUNCHER'
    );

/**
 * Returns the highest priority among all intent-filters of an activity.
 * @param {object} element - The activity or alias element.
 * @returns {number} - The highest priority value (defaults to 0 if not defined).
 */
function getHighestPriority(element) {
    if (!Array.isArray(element['intent-filter'])) {
        return 0;
    }
    return element['intent-filter'].reduce((max, filter) => {
        const priority = parseInt(filter?.['$']?.['android:priority'] || 0, 10);
        return Math.max(max, priority);
    }, 0);
}

/**
 * Extracts the name of either the main application class or the main launcher activity class from the Android manifest.
 * @param {object} manifest - The parsed Android manifest.
 * @returns {object|null} - An object containing the processed class name with '.smali' and type, or null if not found.
 */
function getLauncherActivity(manifest) {
    delayedLog('[★] Attempting to Locate the Main Application Class...');

    const application = manifest?.manifest?.application?.[0];
    if (!application) {
        delayedLog('[!] No <application> tag found in manifest.', CONSTANTS.logStatus.ERROR);
        return null;
    }

    // Extract package name
    const packageName = manifest?.manifest?.['$']?.['package'];
    if (!packageName) {
        delayedLog('[!] No package name found in manifest. Invalid manifest.', CONSTANTS.logStatus.ERROR);
        return null;
    }

    // Extract and process the main application class
    const mainApplicationClassName = application?.['$']?.['android:name'];
    if (mainApplicationClassName) {
        if (!isSystemClass(mainApplicationClassName)) {
            delayedLog(`[¡] Found Main Application Class: ${mainApplicationClassName}`, CONSTANTS.logStatus.INFO);
            return { className: processClassName(mainApplicationClassName), type: 'application' };
        } else {
            delayedLog('[!] Main Application Class is a System Class or Invalid.', CONSTANTS.logStatus.WARNING);
        }
    } else {
        delayedLog('[!] No Main Application Class Found.', CONSTANTS.logStatus.INFO);
    }

    delayedLog('[★] Attempting to Locate the Main Launcher Activity Class...');

    // Find all enabled activities with MAIN action and LAUNCHER category
    const activities = application?.['activity'];
    if (Array.isArray(activities)) {
        const launcherActivities = activities
            .filter(activity => isEnabled(activity))
            .filter(activity => {
                const intentFilters = activity?.['intent-filter'];
                return Array.isArray(intentFilters) && intentFilters.some(isLauncherActivity);
            });

        if (launcherActivities.length > 0) {
            // Sort activities based on the highest priority among their intent-filters
            launcherActivities.sort((a, b) => getHighestPriority(b) - getHighestPriority(a));

            const mainActivityClassName = launcherActivities[0]?.['$']?.['android:name'];
            if (mainActivityClassName && !isSystemClass(mainActivityClassName)) {
                const processedActivityName = processClassName(mainActivityClassName);
                delayedLog('[¡] Scoped the Main Launcher Activity Class for Hooking...', CONSTANTS.logStatus.INFO);
                return { className: processedActivityName, type: 'launcher' };
            } else {
                delayedLog('[!] Main Launcher Activity Class is a System Class or Invalid.', CONSTANTS.logStatus.WARNING);
            }
        } else {
            delayedLog('[!] No Main Launcher Activity Class Found.', CONSTANTS.logStatus.ERROR);
        }
    }

    delayedLog('[i] Checking activity aliases...', CONSTANTS.logStatus.INFO);

    // Handling activity aliases
    const activityAliases = application?.['activity-alias'];
    const validAliases = [];

    if (activityAliases && Array.isArray(activityAliases)) {
        const targetActivities = new Set(); // To track unique target activities

        for (const activityAlias of activityAliases) {
            // Only process aliases that are enabled
            if (!isEnabled(activityAlias)) continue;

            const intentFilter = activityAlias?.['intent-filter'];
            if (Array.isArray(intentFilter)) {
                const isLauncherAlias = intentFilter.some(isLauncherActivity);
                if (isLauncherAlias) {
                    let targetActivityName = activityAlias?.['$']?.['android:targetActivity'];
                    if (targetActivityName && targetActivityName.trim() !== '') {
                        const processedTargetActivity = processClassName(targetActivityName);
                        // Strip '.smali' extension for Set comparison (manifest class names don't have it)
                        const classNameWithoutExtension = processedTargetActivity.replace('.smali', '');
                        if (!targetActivities.has(classNameWithoutExtension)) {
                            targetActivities.add(classNameWithoutExtension);
                            validAliases.push(processedTargetActivity);
                            delayedLog(`[¡] Scoped the Main Launcher Activity Class in an Alias for Hooking: ${processedTargetActivity}`, CONSTANTS.logStatus.INFO);
                        }
                    } else {
                        delayedLog('[!] Invalid or missing targetActivity in alias.', CONSTANTS.logStatus.WARNING);
                    }
                }
            }
        }

        if (validAliases.length > 0) {
            return { className: validAliases[0], type: 'launcher' };
        } else {
            delayedLog('[!] No Main Launcher Activity Class Found in Aliases.', CONSTANTS.logStatus.WARNING);
        }
    } else {
        delayedLog('[!] No Activity Aliases Present in Manifest.', CONSTANTS.logStatus.INFO);
    }

    return null;
}
```
</details>
